full
# matrix(c(z1,z2),ncol=2)
}
genCovValues()
genCovValues(p=c(0.5,0.5,0.5)
)
genCovValues(p=c(0.5,0.5),N=500)
genCovValues(p=c(0.5,0.5),N=10)
test = genCovvV
test = genCovValues()
test = genCovValues(p=c(0.5,0.5),N=10)
covValues = genCovValues(p=c(0.5,0.5),N=10)
psd=function(x,p1=3/4,best = 0,tr = NULL,n.trt)
{
if (best == 0) trts = seq(0,n.trt) else trts = c(0,best)
if (is.null(tr)) keeps = rep(TRUE,nrow(x)) else keeps = c(tr %in% trts,rep(TRUE,nrow(x)-length(tr)))
if (is.null(tr)) arrival = as.matrix(ade4::acm.disjonctif(x)) else arrival = as.matrix(ade4::acm.disjonctif(x[keeps,]))
# arrival = as.matrix(ade4::acm.disjonctif(x))
weight = rep(1,ncol(arrival))
s = length(tr[tr %in% trts]) + 1
n.trt = length(trts)
N = nrow(arrival)
base = matrix(rep(0,n.trt*ncol(arrival)),ncol=ncol(arrival))
for ( i in 1:length(trts)) base[i,] = colSums(arrival[which(tr[tr %in% trts]==trts[i]),])
if (is.null(tr)) tr=rep(NA,N) else tr = tr[keeps]
out = list()
trin = which(trts==trts)
delts = rep(0,(n.trt))
while(s<=N)
{
for ( i in 1:length(trts)) {
inc = base
inc[i,] = base[i,] + t(arrival[s,])
delts[i]=t(arrival[s,])%*%(Rfast::colrange(inc)*weight)
}
p=g(delts,p1,n.trt)
tr[s] = sample(trts,1,p,replace=TRUE)
base[which(trts==tr[s]),] = base[which(trts==tr[s]),] + t(arrival[s,])
s=s+1
}
tr
}
covValues = genCovValues(p=c(0.5,0.5),N=10)
treat = psd(covValues,p1=3/4,best = 0,tr = NULL,n.trt = 2)
treat
data = simulatedata.car(mean.s=c(0,0,0),mean.t=c(0,0,0),sigma0=1,sigma=1,rho = 0.5,tau1 = 1,tau2 = 1,treat,covValues)
# p = 3/4
# n.trt = length(mean.s)-1
# z1=sample(2,N,p1)
# z2=sample(2,N,p2)
# all = genCovValues(p1,p2,N)
# if (design == "Pocock") assn = psd(x=all,best = 2,tr=data$treat) else assn = spbd(x,N)[[1]]
trts = unique(treat)
keeps = treat %in% trts
simulatedata.car  <- function(mean.s,mean.t,sigma0 = 1,sigma=1,rho = .5, tau1 = 1, tau2 = 2,treat,covValues)
# simulate multiple treatment groups
{
trts = unique(treat)
keeps = treat %in% trts
n.trt = length(unique(treat))-1
n.s = table(treat)
n.t = ceiling(n.s/2)
diff = n.s-n.t
mean.full.s = rep(rep(0,n.trt+1),n.s)
mean.full.t = rep(rep(0,n.trt+1),n.s)
for (trt in seq(0,n.trt))
{
mean.full.t[treat==trt] = c(rep(mean.t[trt+1], n.t[trt+1]),rep(NA,diff[trt+1]))
mean.full.s[treat==trt] = rep(mean.s[trt+1], n.s[trt+1])
# mean.full.s[treat==trt] = rep(mean.s[trt+1], sum(treat == trt))
# mean.full.t[treat==trt] = rep(mean.t[trt+1], sum(treat==trt))
}
mean.full = cbind(mean.full.s,mean.full.t)
# simulate error about mean zero then add on treatment effects
mean = c(0,0)
var = c(sigma0^2,rho*sigma0*sigma,rho*sigma0*sigma,sigma^2)
dim(var) = c(2,2)
full.error = mvtnorm::rmvnorm(nrow(mean.full),mean,var)
full.data  = full.error + mean.full + tau1*all[keeps,1] + tau2*all[keeps,2]
data.frame(s=full.data[,1],t=full.data[,2],treat=treat)
}
keeps = treat %in% trts
data = simulatedata.car(mean.s=c(0,0,0),mean.t=c(0,0,0),sigma0=1,sigma=1,rho = 0.5,tau1 = 1,tau2 = 1,treat,covValues)
simulatedata.car  <- function(mean.s,mean.t,sigma0 = 1,sigma=1,rho = .5, tau1 = 1, tau2 = 2,treat,covValues)
# simulate multiple treatment groups
{
trts = unique(treat)
keeps = treat %in% trts
n.trt = length(unique(treat))-1
n.s = table(treat)
n.t = ceiling(n.s/2)
diff = n.s-n.t
mean.full.s = rep(rep(0,n.trt+1),n.s)
mean.full.t = rep(rep(0,n.trt+1),n.s)
for (trt in seq(0,n.trt))
{
mean.full.t[treat==trt] = c(rep(mean.t[trt+1], n.t[trt+1]),rep(NA,diff[trt+1]))
mean.full.s[treat==trt] = rep(mean.s[trt+1], n.s[trt+1])
# mean.full.s[treat==trt] = rep(mean.s[trt+1], sum(treat == trt))
# mean.full.t[treat==trt] = rep(mean.t[trt+1], sum(treat==trt))
}
mean.full = cbind(mean.full.s,mean.full.t)
# simulate error about mean zero then add on treatment effects
mean = c(0,0)
var = c(sigma0^2,rho*sigma0*sigma,rho*sigma0*sigma,sigma^2)
dim(var) = c(2,2)
full.error = mvtnorm::rmvnorm(nrow(mean.full),mean,var)
full.data  = full.error + mean.full + tau1*covValues[keeps,1] + tau2*covValues[keeps,2]
data.frame(s=full.data[,1],t=full.data[,2],treat=treat)
}
data = simulatedata.car(mean.s=c(0,0,0),mean.t=c(0,0,0),sigma0=1,sigma=1,rho = 0.5,tau1 = 1,tau2 = 1,treat,covValues)
data
covValues = genCovValues(p=c(0.5,0.5),N=10)
treat = psd(covValues,p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
treat
simulatedata.car  <- function(mean.s,mean.t,sigma0 = 1,sigma=1,rho = .5, tau1 = 1, tau2 = 1,treat,covValues)
# simulate multiple treatment groups
{
trts = unique(treat)
keeps = treat %in% trts
n.trt = length(unique(treat))-1
n.s = table(treat)
n.t = ceiling(n.s/2)
diff = n.s-n.t
mean.full.s = rep(rep(0,n.trt+1),n.s)
mean.full.t = rep(rep(0,n.trt+1),n.s)
for (trt in seq(0,n.trt))
{
mean.full.t[treat==trt] = c(rep(mean.t[trt+1], n.t[trt+1]),rep(NA,diff[trt+1]))
mean.full.s[treat==trt] = rep(mean.s[trt+1], n.s[trt+1])
# mean.full.s[treat==trt] = rep(mean.s[trt+1], sum(treat == trt))
# mean.full.t[treat==trt] = rep(mean.t[trt+1], sum(treat==trt))
}
mean.full = cbind(mean.full.s,mean.full.t)
# simulate error about mean zero then add on treatment effects
mean = c(0,0)
var = c(sigma0^2,rho*sigma0*sigma,rho*sigma0*sigma,sigma^2)
dim(var) = c(2,2)
full.error = mvtnorm::rmvnorm(nrow(mean.full),mean,var)
full.data  = full.error + mean.full + tau1*covValues[keeps,1] + tau2*covValues[keeps,2]
data.frame(s=full.data[,1],t=full.data[,2],treat=treat)
}
data = simulatedata.car(mean.s=c(0,0,0),mean.t = c(0,0,0), sigma0 = 1, sigma = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat = treat, covValues = covValues)
covValues = genCovValues(p=c(0.5,0.5),N=10)
treat = psd(covValues,p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
treat
data = simulatedata.car(mean.s=c(0,0,0),mean.t = c(0,0,0), sigma0 = 1, sigma = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat = treat, covValues = covValues)
data
get.z.v.Current(data)
z.v = get.z.v.Current(data)
z.v
z = z.v[1]
v = z.v[2]
best = z.v.[3]
best = z.v[3]
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks = 1,v,k=c(3,0),alpha.star.u,alpha.star.l)
getwd()
document()
library(devtools)
library(roxygen2)
document()
setwd("..")
install("seamlessTrials")
### Example file for seamlessTrials package
library(seamlessTrials)
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
getwd(_)
getwd()
### Example file for seamlessTrials package
library(seamlessTrials)
set.seed(101010)
zindex = 1
vindex = 2
bestindex = 3
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5,N=10))
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
#Calculating test statistics z & v for this data, and selecting the best treatment
z.v = get.z.v.Current(data)
data
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5,N=10))
genCovValues()
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=10))
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=10)
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
#Calculating test statistics z & v for this data, and selecting the best treatment
z.v = get.z.v.Current(data)
data
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=100)
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=20)
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
data
#Calculating test statistics z & v for this data, and selecting the best treatment
z.v = get.z.v.Current(data)
z = z.v[zindex]
v = z.v[vindex]
best = z.v[bestindex]
n.trt = length(unique(data$treat))-1
trts = unique(data$treat)
z = rep(0,length(trts)-1)
# dim(z) <- c(n.trt,2)
v = rep(0,length(trts)-1)
# interim analysis
# double regression as in Engel and Walstra (Biometrics 1991)
# N1 is the short term endpoint
# s.N1 = data$s[data$treat==0][1:N1]
# for (treat in seq(1,n.trt)) s.N1 = c(s.N1,data$s[data$treat==treat][1:N1])
s.N1=NULL
for (treat in trts) s.N1 = c(s.N1,data$s[data$treat==treat])
treat.N1 = rep(trts,table(data$treat)) # Does this accuratly account for Pocock?
reg1 = lm(s.N1~factor(treat.N1))
b.hat = reg1$coef[2:(n.trt+1)]
var.b.hat = vcov(reg1)[2:(n.trt+1),2:(n.trt+1)]
sigma.0.hat = summary(reg1)$sigma
# s.n1 = data$s[data$treat==0][1:n1]
# for (treat in seq(1,n.trt)) s.n1 = c(s.n1,data$s[data$treat==treat][1:n1])
#
s.n1 = na.omit(data)$s
# t.n1 = data$t[data$treat==0][1:n1]
t.n1 = na.omit(data)$t
# for (treat in seq(1,n.trt)) t.n1 = c(t.n1,data$t[data$treat==treat][1:n1])
treat.n1 = rep(trts,table(na.omit(data)$treat))
reg2 = lm(t.n1~factor(treat.n1)+s.n1)
beta.hat = reg2$coef[2:(n.trt+1)]
var.beta.hat = vcov(reg2)[2:(n.trt+1),2:(n.trt+1)]
gamma.hat = reg2$coef[n.trt+2]
var.gamma.hat = vcov(reg2)[n.trt+2,n.trt+2]
cov.beta.hat.gamma.hat = vcov(reg2)[2:(n.trt+1),n.trt+2]
sigma.1.hat = summary(reg2)$sigma
B.hat = beta.hat + gamma.hat*b.hat
sigma.hat = sqrt( sigma.1.hat^2 + sigma.0.hat^2 * gamma.hat^2)
rho.hat = gamma.hat*sigma.0.hat/sigma.hat
expected.var.B.hat = 2*sigma.hat^2*( (1-rho.hat^2)/table(na.omit(data$treat)[1:n.trt]) + rho.hat^2/table(data$treat)[1:n.trt])
table(na.omit(data$treat)[1:n.trt])
expected.var.B.hat = 2*sigma.hat^2*( (1-rho.hat^2)/table(na.omit(data$treat)[1:n.t]) + rho.hat^2/table(data$treat)[1:n.t])
table(na.omit(data$treat))
table(na.omit(data$treat))[1:n.trt]
expected.var.B.hat = 2*sigma.hat^2*( (1-rho.hat^2)/table(na.omit(data$treat))[1:n.t] + rho.hat^2/table(data$treat)[1:n.t])
expected.var.B.hat = 2*sigma.hat^2*( (1-rho.hat^2)/table(na.omit(data$treat))[1:n.trt] + rho.hat^2/table(data$treat)[1:n.trt])
get.z.v.Current <- function(data)
{
# gets z and v for all treatments at first look and for selected treatment at second look
# selection is of best treatment from first look
n.trt = length(unique(data$treat))-1
trts = unique(data$treat)
# keep = unique(c(0,trts[trts!=best]))
z = rep(0,length(trts)-1)
# dim(z) <- c(n.trt,2)
v = rep(0,length(trts)-1)
# dim(v) <- c(n.trt,2)
# interim analysis
# double regression as in Engel and Walstra (Biometrics 1991)
# N1 is the short term endpoint
# s.N1 = data$s[data$treat==0][1:N1]
# for (treat in seq(1,n.trt)) s.N1 = c(s.N1,data$s[data$treat==treat][1:N1])
s.N1=NULL
for (treat in trts) s.N1 = c(s.N1,data$s[data$treat==treat])
treat.N1 = rep(trts,table(data$treat)) # Does this accuratly account for Pocock?
reg1 = lm(s.N1~factor(treat.N1))
b.hat = reg1$coef[2:(n.trt+1)]
var.b.hat = vcov(reg1)[2:(n.trt+1),2:(n.trt+1)]
sigma.0.hat = summary(reg1)$sigma
# s.n1 = data$s[data$treat==0][1:n1]
# for (treat in seq(1,n.trt)) s.n1 = c(s.n1,data$s[data$treat==treat][1:n1])
#
s.n1 = na.omit(data)$s
# t.n1 = data$t[data$treat==0][1:n1]
t.n1 = na.omit(data)$t
# for (treat in seq(1,n.trt)) t.n1 = c(t.n1,data$t[data$treat==treat][1:n1])
treat.n1 = rep(trts,table(na.omit(data)$treat))
reg2 = lm(t.n1~factor(treat.n1)+s.n1)
beta.hat = reg2$coef[2:(n.trt+1)]
var.beta.hat = vcov(reg2)[2:(n.trt+1),2:(n.trt+1)]
gamma.hat = reg2$coef[n.trt+2]
var.gamma.hat = vcov(reg2)[n.trt+2,n.trt+2]
cov.beta.hat.gamma.hat = vcov(reg2)[2:(n.trt+1),n.trt+2]
sigma.1.hat = summary(reg2)$sigma
B.hat = beta.hat + gamma.hat*b.hat
sigma.hat = sqrt( sigma.1.hat^2 + sigma.0.hat^2 * gamma.hat^2)
rho.hat = gamma.hat*sigma.0.hat/sigma.hat
expected.var.B.hat = 2*sigma.hat^2*( (1-rho.hat^2)/table(na.omit(data$treat))[1:n.trt] + rho.hat^2/table(data$treat)[1:n.trt])
z = B.hat/expected.var.B.hat
v = rep(1/expected.var.B.hat,n.trt)
# final analysis - selecting best treatment
# make treatment selection
best = trts[trts!=0][z==max(z)]
if (length(best) > 1) best = sample(best,1) # breaks ties at random
data.frame(z =z[which(trts==best)],v = v[which(trts==best)],treat=best)
}
getwd()
install("seamlessTrials")
### Example file for seamlessTrials package
library(seamlessTrials)
set.seed(101010)
zindex = 1
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=10)
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
#Calculating test statistics z & v for this data, and selecting the best treatment
z.v = get.z.v.Current(data)
z = z.v[zindex]
v = z.v[vindex]
best = z.v[bestindex]
z.v
n.looks = 1
k = c(2,rep(1,n.looks-1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
### Example file for seamlessTrials package
library(seamlessTrials)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
setwd("seamlessTrials")
document()
setwd("..")
install("seamlessTrials")
### Example file for seamlessTrials package
library(seamlessTrials)
set.seed(101010)
zindex = 1
vindex = 2
### Example file for seamlessTrials package
library(seamlessTrials)
set.seed(101010)
zindex = 1
vindex = 2
bestindex = 3
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=10)
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
#Calculating test statistics z & v for this data, and selecting the best treatment
z.v = get.z.v.Current(data)
z = z.v[zindex]
v = z.v[vindex]
best = z.v[bestindex]
k = c(2,rep(1,n.looks-1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
n.looks = 1
k = c(2,rep(1,n.looks-1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
v
k = c(3,rep(1,n.looks-1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
k = c(3,rep(1,1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
n.looks = 1
v = v
k = c(3,1)
alpha.star.u=c(0,0.025), alpha.star.l=c(0,0.975)
alpha.star.u=c(0,0.025)
alpha.star.l=c(0,0.975)
inc.v = get.increments(v)
get.increments <- function(x)
{
inc.x = rep(0,length(x))
inc.x[1] = x[1]
if (length(x) > 1) for (i in seq(2,length(x))) inc.x[i]=x[i]-x[i-1]
inc.x
}
inc.v = get.increments(v)
inc.v
inc.alpha.star.u = get.increments(alpha.star.u)
inc.alpha.star.l = get.increments(alpha.star.l)
upper = rep(0,n.looks)
lower = rep(0,n.looks)
for (look in seq(1,n.looks))
{
# find boundaries for this look using spending functions unless both spending function increments are 0
if (look==1) alpha.spent=0
else alpha.spent=alpha.star.u[look-1]+alpha.star.l[look-1]
if (look ==1)
{
# these values are not used but need to be set to get function call correct
upper.prev=0
lower.prev=0
density.prev=0
}
else
{
upper.prev = upper[look-1]
lower.prev = lower[look-1]
}
if (inc.alpha.star.u[look] == 0) upper[look] = 10*sqrt(v[look])
else upper[look] = uniroot(distribution.search.function, lower=-10*sqrt(v[look]), upper=10*sqrt(v[look]), look=look, k=k[look], incv=inc.v[look], upper.prev=upper.prev, lower.prev=lower.prev, n.grid=n.grid, density.prev=density.prev, target=(1-alpha.spent-inc.alpha.star.u[look]))$root
if (inc.alpha.star.l[look] ==0) lower[look] = -10*sqrt(v[look])
else lower[look] = uniroot(distribution.search.function, lower=-10*sqrt(v[look]), upper=10*sqrt(v[look]), look=look, k=k[look], incv=inc.v[look], upper.prev=upper.prev, lower.prev=lower.prev, n.grid=n.grid, density.prev=density.prev, target=inc.alpha.star.l[look])$root
# set up grid and density for next look
if (look < n.looks)
{
z.grid = seq(lower[look],upper[look],(upper[look]-lower[look])/(n.grid-1))
dens = rep(0,n.grid)
if (look==1)
for (i in seq(1,n.grid))
dens[i] = get.max.density(k[look], inc.v[look], z.grid[i])
else
{
#  integrate to give convolution of current density function with previous density
z.grid.prev = seq(lower[look-1],upper[look-1],(upper[look-1]-lower[look-1])/(n.grid-1))
values = rep(0,n.grid)
for (i in seq(1,n.grid))
{
for (j in seq(1,n.grid))
values[j] = get.max.density(k[look],inc.v[look],z.grid[i]-z.grid.prev[j])*density.prev[j]
integral = (values[1] + 2*sum(values[2:(n.grid-1)]) + values[n.grid])*(upper[look-1]-lower[look-1])/(2*(n.grid-1))
dens[i] = integral
}
}
# store density from previous look to use in integration
density.prev = dens
}
}
# stopping boundaries
boundaries <- data.frame(lower,upper)
boundaries
zv
z.v
boundaries = get.boundaries(n.looks, v, k)
boundaries
n.looks = 1
# get critical value based on observed v
k = c(3,rep(1,n.looks-1))
n.looks = 2
# get critical value based on observed v
k = c(3,rep(1,n.looks-1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
n.looks = 2
boundaries = get.boundaries(n.looks, v, k)
z = z.v[zindex]
v = z.v[vindex]
boundaries = get.boundaries(n.looks, v, k)
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k)
inc.v = get.increments(v)
inc.alpha.star.u = get.increments(alpha.star.u)
inc.alpha.star.l = get.increments(alpha.star.l)
n.grid = 1001
upper = rep(0,n.looks)
z = z.v[zindex]
v = z.v[vindex]
best = z.v[bestindex]
n.looks = 1
k = c(3,rep(1,1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k)
boundaries
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
### Example file for seamlessTrials package
library(seamlessTrials)
set.seed(101010)
zindex = 1
vindex = 2
bestindex = 3
#Generating sample covariate values
covValues = genCovValues(p = c(0.5,0.5),N=10)
#Getting treatment value assignments
treat = psd(covValues, p1 = 3/4, best = 0, tr = NULL, n.trt = 2)
#Simulating data for these treatment assignments
data = simulatedata.car(mean.s = c(0,0,0), mean.t = c(0,0,0), sigma = 1, sigma0 = 1, rho = 0.5, tau1 = 1, tau2 = 1, treat, covValues)
#Calculating test statistics z & v for this data, and selecting the best treatment
z.v = get.z.v.Current(data)
z = z.v[zindex]
v = z.v[vindex]
best = z.v[bestindex]
n.looks = 1
k = c(3,rep(1,1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
k = c(2,rep(1,1))
alpha.star.u=c(0.001,0.010,0.019,0.024,0.025)
alpha.star.l=c(0.185,0.733,0.933,0.973,0.975)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u, alpha.star.l)
boundaries = get.boundaries(n.looks, v, k, alpha.star.u[n.looks], alpha.star.l[n.looks])
boundaries = get.boundaries(n.looks, v, k)
boundaries

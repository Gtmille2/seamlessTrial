f_upr = lower_search_fn(upperLimit,numberInspections)
while ( loop < BINARY_SEARCH_MAX_ITERATIONS) {
mid_val = (upperLimit+lowerLimit)/2
if( abs(mid_val) >= CLOSE_ZERO & abs((upperLimit - mid_val)/mid_val) < SEARCH_TOLERANCE)
return(mid_val)
loop = loop + 1
f_mid = lower_search_fn(mid_val,numberInspections)
if(f_mid*f_upr == 0 ){
return(mid_val)
}
else{
if(f_mid*f_upr > 0 )
{
upperLimit = mid_val
f_upr = f_mid
}
else {
lowerLimit = mid_val
}
}
}
#print(mid_val)
return(mid_val)
}
binarySearchV = function(lowerLimit,upperLimit,numberInspections) {
loop = 0
f_upr = v_search_fn(upperLimit)
#print(lowerLimit)
#print(upperLimit)
while ( loop < BINARY_SEARCH_MAX_ITERATIONS) {
mid_val = (upperLimit+lowerLimit)/2
if( abs(mid_val) >= CLOSE_ZERO & abs((upperLimit - mid_val)/mid_val) < SEARCH_TOLERANCE)
return(mid_val)
loop = loop + 1
f_mid = v_search_fn(mid_val)
if(f_mid*f_upr == 0 ){
return(mid_val)
}
else{
if(f_mid*f_upr > 0 )
{
upperLimit = mid_val
f_upr = f_mid
}
else {
lowerLimit = mid_val
}
}
}
return(mid_val)
}
main()
monitorArray
###working on the getting upperboundary and lower boundary functions
#pnorm is gfast
#dnorm is normaldensity
library(pracma)
ntmt = 3
numberInspectionsMax = 6
alpha_star_u = c(0 , 0.000000, 0.001226, 0.009513, 0.018794, 0.024457, 0.025000)
alpha_star_l = c(0 ,0.000000,  0.184595, 0.733395, 0.933759, 0.973494, 0.975000)
ARRVALUE = 2
ARRDENSITY = 1
ARRWEIGHT = 3
LOWER_BOUNDI = 1
UPPER_BOUNDI = 2
# v = c(0,0.2,.4,.6,.8,1)
# v = c(0,0.5,1)
# vmax = 50
# UPPER_BOUND_I = c(5)
# LOWER_BOUND_I = c(0)
VI = 3
ZI = 4
TOLERANCE = 0.00000000001
SEARCH_TOLERANCE = 0.0000001
CLOSE_ZERO = 0.000000000001
BINARY_SEARCH_MAX_ITERATIONS = 400
INTEGR_POINTS = 101
INTEGR_POINTS_First = 151
##monitoryArray = matrix(c(UPPER_BOUND_I,LOWER_BOUND_I,VI,ZI),nrow=2,byrow=TRUE)
boundsarr = list(c(0,0))
monitorArray = list(c(0,0,0,0))
stdmonitorArray = list(c(0,0,0,0))
densityFunctionDiscreteArray = list(c(0))
array = list(c(0))
theta = rep(0,ntmt)
theta1 = rep(0,ntmt)
rho = 0.05
# for ( i in 1:length(alpha_star_l)) cat("Bounds: ",alpha_star_u[i]," ",alpha_star_l[i],"\n")
main = function() {
ntmt = 3
numberInspectionsMax = 6
for ( i in 1:(numberInspectionsMax + 2)) monitorArray[[i]] <<- c(0,0,0,0)
for ( i in 1:(numberInspectionsMax + 2)) stdmonitorArray[[i]] <<- c(0,0,0,0)
vmax = binarySearchV(62.5,200)
cat("Boundary \n")
for ( j in 1:numberInspectionsMax) cat(monitorArray[[j+1]][VI]," ",monitorArray[[j+1]][LOWER_BOUNDI]," ",monitorArray[[j+1]][UPPER_BOUNDI],"\n")
cat(" \n \n ")
print("Properties under the null")
theta[1] <<- 0
theta[2] <<- 0
theta[3] <<- 0
theta1[1] <<- 0
theta1[2] <<- 0
theta1[3] <<- 0
power = getErrorRates(0,numberInspectionsMax-1,1)
print("Properties under alternative")
theta[1] <<- 0.315
theta[2] <<- 0.24
theta[3] <<- 0.24
theta1[1] <<- (1.08-0.52)/.6
theta1[2] <<- (0.68-0.52)/.6
theta1[3] <<- (0.68-0.52)/.6
power = getErrorRates(1,numberInspectionsMax-1,1)
cat("Power Here: ", power, "\n")
power = getErrorRates(0,numberInspectionsMax-1,1)
cat("Power Here: ", power, "\n")
}
v_search_fn = function(vmax) {
monitorArray[[1]][VI] <<- 0
monitorArray[[2]][VI] <<- 12.5
# print(vmax)
for ( j in 3:(numberInspectionsMax+1)) {
monitorArray[[j]][VI] <<- vmax*(j-2)/(numberInspectionsMax-1)
#cat("Monitor Array at Point: ",j," ",monitorArray[[j]][VI]," \n")
}
for ( j in 1:ntmt) theta[j] <<- 0
for ( j in 1:ntmt) theta1[j] <<- 0
for ( numberInspections in 1:(numberInspectionsMax) ) {
if(numberInspections == 1) {
monitorArray[[numberInspections]][UPPER_BOUNDI]  <<- 0
monitorArray[[numberInspections]][LOWER_BOUNDI] <<- 0
}
if ( numberInspections > 1) {
#cat("numberInspections here: ",numberInspections,"\n")
densityFunctionDiscreteArray <<- densityArray(0,numberInspections-1,INTEGR_POINTS)
upperBoundary = binarySearchUpper(0,5*sqrt(monitorArray[[numberInspections+1]][VI]),numberInspections)
lowerBoundary = binarySearchLower(-5*sqrt(monitorArray[[numberInspections+1]][VI]),5*sqrt(monitorArray[[numberInspections+1]][VI]),numberInspections)
#cat("lowerBoundary here: ", lowerBoundary,"\n")
#Think I have to use two different functions for upper and lower since R can't do pointer functions
monitorArray[[numberInspections+1]][UPPER_BOUNDI] <<- upperBoundary
monitorArray[[numberInspections+1]][LOWER_BOUNDI] <<- lowerBoundary
#cat("upperBoundary: ",upperBoundary," lowerBoundary: ",lowerBoundary,"\n")
}
}
theta[1]<<-0.315
theta[2]<<-0.24
theta[3]<<-0.24
theta1[1]<<-(1.08-0.52)/.6
theta1[2]<<-(0.68-0.52)/.6
theta1[3]<<-(0.68-0.52)/.6
difference = getErrorRates(1,numberInspectionsMax-1,0)-.9
if (numberInspections > 1)
cat("vmax: ",vmax, "difference: ",difference,"\n")
return(difference)
}
upper_search_fn = function(upperBoundary,numberInspections) {
target = alpha_star_u[numberInspections+1] - alpha_star_u[numberInspections]
monitorArray[[numberInspections+1]][UPPER_BOUNDI] <<- upperBoundary
monitorArray[[numberInspections+1]][LOWER_BOUNDI] <<- 0
#cat("target: ",target,"UpperBoundary: ",monitorArray[[numberInspections+1]][[UPPER_BOUNDI]],"\n")
return(probCrossUpperDiscrete(0,numberInspections)-target)
}
lower_search_fn = function(lowerBoundary,numberInspections) {
target = alpha_star_l[numberInspections + 1] - alpha_star_l[numberInspections]
monitorArray[[numberInspections+1]][UPPER_BOUNDI] <<- 0
monitorArray[[numberInspections+1]][LOWER_BOUNDI] <<- lowerBoundary
return(probCrossLowerDiscrete(0,numberInspections) - target)
}
getErrorRates = function(get_power,numberInspections,print) {
alpha_u = 0
alpha_l = 0
#cat("numberInspections: ",numberInspections,"\n")
densityFunctionDiscreteArray <<- densityArray(get_power,numberInspections,INTEGR_POINTS)
for ( inspection in 1:(numberInspections+1)) {
#print("hereeeeeeeeeeeeeee")
alpha_u = alpha_u + probCrossUpperDiscrete(get_power,inspection)
#cat("alpha_u: ",alpha_u, "\n")
if ( get_power == 0) alpha_l = alpha_l + probCrossLowerDiscrete(get_power,inspection)
if ( print == 1 & get_power == 0) cat("alpha_u: ", alpha_u, "alpha_l", alpha_l,"\n")
if ( print == 1 & get_power == 1) cat("alpha_u: ",alpha_u,"\n")
}
if (print==1 & get_power == 0) cat("alpha_u: ",alpha_u, "alpha_l", alpha_l,"\n")
if (print==1 & get_power == 1) cat("alpha_u: ",alpha_u,"\n")
return(alpha_u)
}
probCrossUpperDiscrete = function(get_power,inspection) {
upperBound = monitorArray[[inspection+1]][UPPER_BOUNDI]
vStep = monitorArray[[inspection+1]][VI] - monitorArray[[inspection]][VI]
# cat("upperBound: ",upperBound," vStep: ",vStep,"inspection: ",inspection, "\n")
if(inspection == 1) {
#print(TRUE)
return(0)
}
else
{
return(integrateNormalDistributionDensityFunctionDiscrete(inspection))
}
}
integrateNormalDistributionDensityFunctionDiscrete = function(inspection) {
integral = 0
vStep = monitorArray[[inspection+1]][VI] - monitorArray[[inspection]][VI]
#cat("vStep in integrate function: ",vStep,"inspection: ",inspection, "\n")
for ( i in 0:(INTEGR_POINTS-1)) {
s = densityFunctionDiscreteArray[[inspection-1]][ARRVALUE,i+1]
if (inspection == 2) {
mu_second = theta[1]*monitorArray[[3]][VI] - rho*sqrt(monitorArray[[3]][VI]/monitorArray[[2]][VI])*
(theta[1]*monitorArray[[2]][VI]-s)
var_second = monitorArray[[3]][VI]*(1-rho*rho)
# #cat("Test: ",monitorArray[[2]][VI],"Test 2: ",monitorArray[[1]][VI],"\n")
normalDistribution = 1 - pnorm((monitorArray[[inspection+1]][UPPER_BOUNDI] - mu_second)/sqrt(var_second))
}
else {
normalDistribution = 1 - pnorm((monitorArray[[inspection+1]][UPPER_BOUNDI] - s - theta[1]*vStep)/sqrt(vStep))
}
#cat("Test 1: ",densityFunctionDiscreteArray[[inspection-1]][ARRWEIGHT,i + 1]," Test 2: ",
#densityFunctionDiscreteArray[[inspection -1]][ARRDENSITY,i+1],"\n")
integral = integral + densityFunctionDiscreteArray[[inspection-1]][ARRWEIGHT,i + 1]*
densityFunctionDiscreteArray[[inspection -1]][ARRDENSITY,i+1]*
normalDistribution
}
#cat("Integral result Here: ", integral, "\n")
return(integral)
}
probCrossLowerDiscrete = function(get_power, inspection) {
lowerBound = monitorArray[[inspection+1]][LOWER_BOUNDI]
vStep = monitorArray[[inspection+1]][VI] - monitorArray[[inspection]][VI]
if(inspection == 1) return(0)
else return (integrateNormalDistributionDensityFunctionDiscreteLower(inspection))
}
integrateNormalDistributionDensityFunctionDiscreteLower = function(inspection) {
integral = 0
vStep = monitorArray[[inspection+1]][VI] - monitorArray[[inspection]][VI]
for ( i in 0:(INTEGR_POINTS - 1)) {
s = densityFunctionDiscreteArray[[inspection-1]][ARRVALUE,i+1]
if ( inspection == 2) {
mu_second = theta[1]*monitorArray[[3]][VI] - rho*sqrt(monitorArray[[3]][VI]/monitorArray[[2]][VI])*
(theta[1]*monitorArray[[2]][VI]-s)
var_second = monitorArray[[3]][VI]*(1-rho*rho)
# #cat("mu_second: ",mu_second,"var_second: ",var_second,"s: ",s,"test: ",monitorArray[[inspection+1]][UPPER_BOUNDI] ,"\n")
normalDistribution = pnorm((monitorArray[[inspection+1]][LOWER_BOUNDI] - mu_second)/sqrt(var_second))
# #cat("normalDistribution: ",normalDistribution,"\n")
}
else {
normalDistribution = pnorm((monitorArray[[inspection+1]][LOWER_BOUNDI] - s - theta[1]*vStep)/sqrt(vStep))
}
integral = integral + densityFunctionDiscreteArray[[inspection-1]][ARRWEIGHT,i+1]*
densityFunctionDiscreteArray[[inspection-1]][ARRDENSITY,i+1]*
normalDistribution
}
#cat("Integral result Here: ", integral, "\n")
return(integral)
}
densityArray = function(get_power,numberInspections,numberIntervals) {
array = list(c(0))
for ( i in 1:numberInspections) array[[i]] = matrix(rep(0,3*INTEGR_POINTS),nrow = 3)
for ( i in 0:(numberInspections-1)) {
lowerLimit = monitorArray[[i+2]][LOWER_BOUNDI]
upperLimit = monitorArray[[i+2]][UPPER_BOUNDI]
if (i == 0) lowerLimit = -10*sqrt(monitorArray[[2]][VI])
if (i == 0) upperLimit = 10*sqrt(monitorArray[[2]][VI])
# cat("lowerLimit: ",lowerLimit,"upperLimit: ",upperLimit,"\n")
arrayvalweights = gaussLegendre(n = INTEGR_POINTS,lowerLimit,upperLimit)
array[[i+1]][ARRVALUE,] = arrayvalweights$x
array[[i+1]][ARRWEIGHT,] = arrayvalweights$w
vStep = monitorArray[[i+2]][VI] - monitorArray[[i+1]][VI]
#cat("vStep: ",vStep,"\n")
if ( i ==0 ) {
for( j in 0:(INTEGR_POINTS-1)){
z = array[[i+1]][ARRVALUE,j+1]
# cat("z: ",z,"\n")
if(get_power==0) {
array[[i+1]][ARRDENSITY,j+1] = get_density_first(ntmt,theta,vStep,z)
}
if (get_power == 1) {
array[[i+1]][ARRDENSITY,j+1] = get_power_first(ntmt,theta,vStep,z)
}
}
# for ( r in 1:11 ) cat("BLAH HERE: ",array[[i+1]][ARRDENSITY,r],"\n")
}
if ( i ==1 ) {
for ( j in 0:(INTEGR_POINTS-1)) {
density = 0.0
z = array[[i+1]][ARRVALUE,j+1]
for( k  in 0:(INTEGR_POINTS-1)){
s  = array[[i]][ARRVALUE,k+1]
mu_second = theta[1]*monitorArray[[3]][VI] - rho*sqrt(monitorArray[[3]][VI]/monitorArray[[2]][VI])*
(theta[1]*monitorArray[[2]][VI] - s)
var_second = monitorArray[[3]][VI]*(1-rho*rho)
density = density + array[[i]][ARRWEIGHT,k+1]*
(1/sqrt(var_second))*dnorm((z-mu_second)/sqrt(var_second))*(array[[i]][ARRDENSITY,k+1])
}
#cat("density :",density,"i: ",i,"\n")
array[[i+1]][ARRDENSITY,j+1] = density
}
}
if ( i >= 2) {
#print(TRUE)
for(j in 0:(INTEGR_POINTS-1) )
{
density = 0
z = array[[i+1]][ARRVALUE,j+1]
for (k in 0:(INTEGR_POINTS-1)) {
s = array[[i]][ARRVALUE,k+1]
density = density + array[[i]][ARRWEIGHT,k+1]*(1/sqrt(vStep))*dnorm((z-s-theta[1]*vStep)/sqrt(vStep))*array[[i]][ARRDENSITY,k+1]
}
# cat("density :",density,"\n")
array[[i+1]][ARRDENSITY,j+1] = density
}
}
}
return(array)
}
get_density_first = function(ntmt,theta,v,z) {
lowerLimit = -20*sqrt(v)
upperLimit = 20*sqrt(v)
xvalweights = gaussLegendre(INTEGR_POINTS_First,lowerLimit,upperLimit)
integral = 0
for ( j in 0 :(INTEGR_POINTS_First-1)){
integral = integral + get_integrand(ntmt,theta,v,z,xvalweights$x[j+1])*xvalweights$w[j+1]
}
return(integral)
}
get_integrand = function(k,theta,v,z,x) {
root = sqrt(v/2)
product = 1
for( i in 1:k ) {
product = product*pnorm((x-theta1[i]*v)/root)
}
integrand = product*2*(x-z)*dnorm((x-z)/root)/(v*root)
return(integrand)
}
get_power_first = function(ntmt,theta,v,z) {
lowerLimit = -20*sqrt(v)
upperLimit = 20*sqrt(v)
xvalweights = gaussLegendre(INTEGR_POINTS_First,lowerLimit,upperLimit)
integral = 0
for ( j in 0:(INTEGR_POINTS_First-1)) {
integral = integral + get_integrand_power(ntmt,theta,v,z,xvalweights$x[j+1])*xvalweights$w[j+1]
}
return(integral)
}
get_integrand_power = function(k,theta,v,z,x) {
root = sqrt(v/2)
product = 1
for ( i in 2:k) {
product = product*pnorm((x-theta1[i]*v)/root)
}
integrand = product*dnorm((x-theta1[1]*v)/root)*dnorm((x-z)/root)*2/v
return(integrand)
}
binarySearchUpper = function(lowerLimit,upperLimit,numberInspections) {
loop = 0
f_upr = upper_search_fn(upperLimit,numberInspections)
#cat("Number inspections: ", numberInspections, " f_upr: ",f_upr, "\n")
while ( loop < BINARY_SEARCH_MAX_ITERATIONS) {
mid_val = (upperLimit+lowerLimit)/2
if( abs(mid_val) >= CLOSE_ZERO & abs((upperLimit - mid_val)/mid_val) < SEARCH_TOLERANCE)
return(mid_val)
loop = loop + 1
f_mid = upper_search_fn(mid_val,numberInspections)
#cat("f_mid: ", f_mid,"\n")
if(f_mid*f_upr == 0 ){
return(mid_val)
}
else{
if(f_mid*f_upr > 0 )
{
upperLimit = mid_val
f_upr = f_mid
}
else {
lowerLimit = mid_val
}
}
}
return(mid_val)
}
binarySearchLower = function(lowerLimit,upperLimit,numberInspections) {
loop = 0
f_upr = lower_search_fn(upperLimit,numberInspections)
while ( loop < BINARY_SEARCH_MAX_ITERATIONS) {
mid_val = (upperLimit+lowerLimit)/2
if( abs(mid_val) >= CLOSE_ZERO & abs((upperLimit - mid_val)/mid_val) < SEARCH_TOLERANCE)
return(mid_val)
loop = loop + 1
f_mid = lower_search_fn(mid_val,numberInspections)
if(f_mid*f_upr == 0 ){
return(mid_val)
}
else{
if(f_mid*f_upr > 0 )
{
upperLimit = mid_val
f_upr = f_mid
}
else {
lowerLimit = mid_val
}
}
}
#print(mid_val)
return(mid_val)
}
binarySearchV = function(lowerLimit,upperLimit,numberInspections) {
loop = 0
f_upr = v_search_fn(upperLimit)
#print(lowerLimit)
#print(upperLimit)
while ( loop < BINARY_SEARCH_MAX_ITERATIONS) {
mid_val = (upperLimit+lowerLimit)/2
if( abs(mid_val) >= CLOSE_ZERO & abs((upperLimit - mid_val)/mid_val) < SEARCH_TOLERANCE)
return(mid_val)
loop = loop + 1
f_mid = v_search_fn(mid_val)
if(f_mid*f_upr == 0 ){
return(mid_val)
}
else{
if(f_mid*f_upr > 0 )
{
upperLimit = mid_val
f_upr = f_mid
}
else {
lowerLimit = mid_val
}
}
}
return(mid_val)
}
v_search_fn = function(vmax) {
monitorArray[[1]][VI] <<- 0
monitorArray[[2]][VI] <<- 12.5
# print(vmax)
for ( j in 3:(numberInspectionsMax+1)) {
monitorArray[[j]][VI] <<- vmax*(j-2)/(numberInspectionsMax-1)
#cat("Monitor Array at Point: ",j," ",monitorArray[[j]][VI]," \n")
}
for ( j in 1:ntmt) theta[j] <<- 0
for ( j in 1:ntmt) theta1[j] <<- 0
for ( numberInspections in 1:(numberInspectionsMax) ) {
if(numberInspections == 1) {
monitorArray[[numberInspections]][UPPER_BOUNDI]  <<- 0
monitorArray[[numberInspections]][LOWER_BOUNDI] <<- 0
}
if ( numberInspections > 1) {
#cat("numberInspections here: ",numberInspections,"\n")
densityFunctionDiscreteArray <<- densityArray(0,numberInspections-1,INTEGR_POINTS)
cat("first",monitorArray[[numberInspections+1]][VI],"second",numberInspections,'\n')
upperBoundary = binarySearchUpper(0,5*sqrt(monitorArray[[numberInspections+1]][VI]),numberInspections)
lowerBoundary = binarySearchLower(-5*sqrt(monitorArray[[numberInspections+1]][VI]),5*sqrt(monitorArray[[numberInspections+1]][VI]),numberInspections)
#cat("lowerBoundary here: ", lowerBoundary,"\n")
#Think I have to use two different functions for upper and lower since R can't do pointer functions
monitorArray[[numberInspections+1]][UPPER_BOUNDI] <<- upperBoundary
monitorArray[[numberInspections+1]][LOWER_BOUNDI] <<- lowerBoundary
#cat("upperBoundary: ",upperBoundary," lowerBoundary: ",lowerBoundary,"\n")
}
}
theta[1]<<-0.315
theta[2]<<-0.24
theta[3]<<-0.24
theta1[1]<<-(1.08-0.52)/.6
theta1[2]<<-(0.68-0.52)/.6
theta1[3]<<-(0.68-0.52)/.6
difference = getErrorRates(1,numberInspectionsMax-1,0)-.9
if (numberInspections > 1)
cat("vmax: ",vmax, "difference: ",difference,"\n")
return(difference)
}
main()
monitorArray
v_search_fn = function(vmax) {
monitorArray[[1]][VI] <<- 0
monitorArray[[2]][VI] <<- 6
# print(vmax)
for ( j in 3:(numberInspectionsMax+1)) {
monitorArray[[j]][VI] <<- vmax*(j-2)/(numberInspectionsMax-1)
#cat("Monitor Array at Point: ",j," ",monitorArray[[j]][VI]," \n")
}
for ( j in 1:ntmt) theta[j] <<- 0
for ( j in 1:ntmt) theta1[j] <<- 0
for ( numberInspections in 1:(numberInspectionsMax) ) {
if(numberInspections == 1) {
monitorArray[[numberInspections]][UPPER_BOUNDI]  <<- 0
monitorArray[[numberInspections]][LOWER_BOUNDI] <<- 0
}
if ( numberInspections > 1) {
#cat("numberInspections here: ",numberInspections,"\n")
densityFunctionDiscreteArray <<- densityArray(0,numberInspections-1,INTEGR_POINTS)
cat("first",monitorArray[[numberInspections+1]][VI],"second",numberInspections,'\n')
upperBoundary = binarySearchUpper(0,5*sqrt(monitorArray[[numberInspections+1]][VI]),numberInspections)
lowerBoundary = binarySearchLower(-5*sqrt(monitorArray[[numberInspections+1]][VI]),5*sqrt(monitorArray[[numberInspections+1]][VI]),numberInspections)
#cat("lowerBoundary here: ", lowerBoundary,"\n")
#Think I have to use two different functions for upper and lower since R can't do pointer functions
monitorArray[[numberInspections+1]][UPPER_BOUNDI] <<- upperBoundary
monitorArray[[numberInspections+1]][LOWER_BOUNDI] <<- lowerBoundary
#cat("upperBoundary: ",upperBoundary," lowerBoundary: ",lowerBoundary,"\n")
}
}
theta[1]<<-0.315
theta[2]<<-0.24
theta[3]<<-0.24
theta1[1]<<-(1.08-0.52)/.6
theta1[2]<<-(0.68-0.52)/.6
theta1[3]<<-(0.68-0.52)/.6
difference = getErrorRates(1,numberInspectionsMax-1,0)-.9
if (numberInspections > 1)
cat("vmax: ",vmax, "difference: ",difference,"\n")
return(difference)
}
main()
